# 字典注解使用规范

## 概述

字典注解（`@Dict`）是Jeecg-boot框架提供的一个强大功能，用于在API返回数据时自动将字典值翻译为对应的文本描述。通过在实体类字段上添加`@Dict`注解，系统会自动在返回的JSON数据中添加对应的`_dictText`字段，实现前端无需额外处理字典翻译的效果。

### 功能特点

- **自动翻译**：无需手动编写字典翻译代码，注解自动处理
- **性能优化**：支持Redis缓存，批量翻译，避免N+1查询问题
- **多种模式**：支持普通字典和表字典两种翻译模式
- **批量处理**：支持逗号分隔的多值翻译
- **缓存机制**：自动缓存翻译结果，提升性能

### 使用场景

- 状态字段翻译（如：订单状态、用户状态等）
- 分类字段翻译（如：商品分类、文档类型等）
- 枚举值翻译（如：性别、优先级等）
- 关联表数据翻译（如：用户ID翻译为用户名）

## 注解参数说明

### @Dict 注解定义

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Dict {
    /**
     * 字典编码（必填）
     * 对应 sys_dict 表的 dict_code 字段
     */
    String dicCode();

    /**
     * 字典文本字段（可选）
     * 用于表字典模式，指定要显示的文本字段名
     * 默认值：""
     */
    String dicText() default "";

    /**
     * 字典表名（可选）
     * 用于表字典模式，指定要查询的表名
     * 默认值：""
     */
    String dictTable() default "";
}
```

### 参数详细说明

| 参数名 | 类型 | 必填 | 默认值 | 说明 | 使用场景 |
|--------|------|------|--------|------|----------|
| `dicCode` | String | 是 | 无 | 字典编码或字段名 | 普通字典：对应dict_code<br/>表字典：对应查询字段名 |
| `dicText` | String | 否 | "" | 显示文本字段名 | 仅表字典模式使用 |
| `dictTable` | String | 否 | "" | 字典表名 | 仅表字典模式使用 |

## 数据库表结构

### 字典主表（sys_dict）

```sql
CREATE TABLE `sys_dict` (
  `id` varchar(32) NOT NULL COMMENT '主键ID',
  `dict_name` varchar(100) NOT NULL COMMENT '字典名称',
  `dict_code` varchar(100) NOT NULL COMMENT '字典编码',
  `description` varchar(255) DEFAULT NULL COMMENT '描述',
  `del_flag` int DEFAULT NULL COMMENT '删除状态',
  `create_by` varchar(32) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(32) DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `type` int(1) unsigned zerofill DEFAULT '0' COMMENT '字典类型0为string,1为number',
  `tenant_id` int DEFAULT '0' COMMENT '租户ID',
  `low_app_id` varchar(32) DEFAULT NULL COMMENT '低代码应用ID',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_sd_dict_code` (`dict_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT='字典配置主表';
```

### 字典项表（sys_dict_item）

```sql
CREATE TABLE `sys_dict_item` (
  `id` varchar(32) NOT NULL COMMENT '主键ID',
  `dict_id` varchar(32) DEFAULT NULL COMMENT '字典id',
  `item_text` varchar(100) NOT NULL COMMENT '字典项文本',
  `item_value` varchar(3000) DEFAULT NULL COMMENT '字典项值',
  `item_color` varchar(10) DEFAULT NULL COMMENT '字典项颜色',
  `description` varchar(255) DEFAULT NULL COMMENT '描述',
  `sort_order` int DEFAULT NULL COMMENT '排序',
  `status` int DEFAULT NULL COMMENT '状态（1启用 0不启用）',
  `create_by` varchar(32) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(32) DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_sditem_role_dict_id` (`dict_id`),
  KEY `idx_sditem_role_sort_order` (`sort_order`),
  KEY `idx_sditem_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT='字典配置项表';
```

## 使用方式

### 1. 普通字典模式

普通字典模式是最常用的方式，通过`sys_dict`和`sys_dict_item`表进行翻译。

#### 1.1 数据准备

```sql
-- 添加字典类型
INSERT INTO `sys_dict` (
    `id`, `dict_code`, `dict_name`, `description`, `del_flag`, 
    `create_by`, `create_time`, `update_by`, `update_time`
) VALUES (
    '1234567890', 'user_status', '用户状态', '用户状态字典', '0',
    'admin', NOW(), 'admin', NOW()
);

-- 添加字典项
INSERT INTO `sys_dict_item` (
    `id`, `dict_id`, `item_text`, `item_value`, `item_color`, 
    `description`, `sort_order`, `status`, `create_by`, 
    `create_time`, `update_by`, `update_time`
) VALUES (
    '1234567891', '1234567890', '正常', '1', '#00FF00',
    '用户正常状态', 1, 1, 'admin', NOW(), 'admin', NOW()
), (
    '1234567892', '1234567890', '禁用', '0', '#FF0000',
    '用户禁用状态', 2, 1, 'admin', NOW(), 'admin', NOW()
);
```

#### 1.2 实体类注解

```java
@Data
@TableName("sys_user")
public class SysUser {
    
    @TableId(type = IdType.ASSIGN_ID)
    private String id;
    
    @Excel(name = "用户名", width = 15)
    private String username;
    
    @Excel(name = "真实姓名", width = 15)
    private String realname;
    
    /**
     * 用户状态字段
     * 使用普通字典翻译
     */
    @Excel(name = "状态", width = 15, dicCode = "user_status")
    @Dict(dicCode = "user_status")
    private Integer status;
    
    /**
     * 性别字段
     * 支持多值翻译（逗号分隔）
     */
    @Excel(name = "性别", width = 15, dicCode = "sex")
    @Dict(dicCode = "sex")
    private String sex;
}
```

#### 1.3 返回结果示例

**原始数据：**
```json
{
  "success": true,
  "result": {
    "records": [
      {
        "id": "1",
        "username": "admin",
        "realname": "管理员",
        "status": 1,
        "sex": "1"
      }
    ]
  }
}
```

**字典翻译后：**
```json
{
  "success": true,
  "result": {
    "records": [
      {
        "id": "1",
        "username": "admin",
        "realname": "管理员",
        "status": 1,
        "status_dictText": "正常",
        "sex": "1",
        "sex_dictText": "男"
      }
    ]
  }
}
```

### 2. 表字典模式

表字典模式用于从其他业务表中获取翻译文本，适用于关联表数据翻译。

#### 2.1 实体类注解

```java
@Data
@TableName("sys_files")
public class SysFiles {
    
    @TableId(type = IdType.ASSIGN_ID)
    private String id;
    
    @Excel(name = "文件名称", width = 15)
    private String fileName;
    
    /**
     * 创建人字段
     * 使用表字典翻译：从 sys_user 表中根据 username 查询 realname
     */
    @Excel(name = "创建人登录名称", width = 15)
    @Dict(dicCode = "username", dicText = "realname", dictTable = "sys_user")
    private String createBy;
}
```

#### 2.2 返回结果示例

**原始数据：**
```json
{
  "id": "1",
  "fileName": "测试文档.pdf",
  "createBy": "admin"
}
```

**字典翻译后：**
```json
{
  "id": "1",
  "fileName": "测试文档.pdf",
  "createBy": "admin",
  "createBy_dictText": "系统管理员"
}
```

### 3. 多值翻译

支持逗号分隔的多个值同时翻译。

#### 3.1 实体类注解

```java
@Data
@TableName("user_role")
public class UserRole {
    
    /**
     * 角色ID字段（多个角色用逗号分隔）
     * 支持多值翻译
     */
    @Dict(dicCode = "role_id", dicText = "role_name", dictTable = "sys_role")
    private String roleIds; // 值如："1,2,3"
}
```

#### 3.2 返回结果示例

**原始数据：**
```json
{
  "roleIds": "1,2,3"
}
```

**字典翻译后：**
```json
{
  "roleIds": "1,2,3",
  "roleIds_dictText": "管理员,普通用户,访客"
}
```

## 工作原理

### 1. 切面拦截

字典翻译通过AOP切面实现，拦截所有Controller方法的返回值：

```java
@Pointcut("execution(public * org.jeecg.modules..*.*Controller.*(..)) || @annotation(org.jeecg.common.aspect.annotation.AutoDict)")
public void excudeService() {
}

@Around("excudeService()")
public Object doAround(ProceedingJoinPoint pjp) throws Throwable {
    Object result = pjp.proceed();
    result = this.parseDictText(result);
    return result;
}
```

### 2. 字典解析流程

1. **检测注解**：扫描返回对象中的`@Dict`注解字段
2. **收集数据**：收集需要翻译的字典代码和值
3. **缓存查询**：优先从Redis缓存中获取翻译结果
4. **数据库查询**：缓存未命中时查询数据库
5. **批量翻译**：一次性翻译所有字典数据
6. **结果填充**：将翻译结果填充到`_dictText`字段

### 3. 缓存机制

- **普通字典缓存键**：`sys:cache:dict::{dictCode}:{value}`
- **表字典缓存键**：`sys:cache:dictTable::SimpleKey [{table},{text},{code},{value}]`
- **缓存时间**：表字典缓存5分钟，普通字典永久缓存

## 最佳实践

### 1. 注解使用规范

```java
// ✅ 正确：普通字典使用
@Dict(dicCode = "user_status")
private Integer status;

// ✅ 正确：表字典使用
@Dict(dicCode = "username", dicText = "realname", dictTable = "sys_user")
private String createBy;

// ❌ 错误：表字典缺少必要参数
@Dict(dicCode = "username", dictTable = "sys_user")  // 缺少 dicText
private String createBy;

// ❌ 错误：普通字典使用了表字典参数
@Dict(dicCode = "user_status", dictTable = "sys_dict")  // 不需要 dictTable
private Integer status;
```

### 2. 字典编码命名规范

```java
// ✅ 推荐：使用下划线分隔的小写字母
@Dict(dicCode = "user_status")
@Dict(dicCode = "order_type")
@Dict(dicCode = "payment_method")

// ❌ 不推荐：使用驼峰命名或大写字母
@Dict(dicCode = "userStatus")
@Dict(dicCode = "ORDER_TYPE")
```

### 3. 性能优化建议

#### 3.1 合理使用字典翻译

```java
// ✅ 推荐：在VO/DTO中使用字典注解
@Data
public class UserVO {
    @Dict(dicCode = "user_status")
    private Integer status;
}

// ❌ 不推荐：在Entity中过度使用字典注解
@Data
@TableName("sys_user")
public class SysUser {
    // 如果不是所有接口都需要翻译，建议在VO中添加注解
    @Dict(dicCode = "user_status")
    private Integer status;
}
```

#### 3.2 避免循环查询

```java
// ✅ 推荐：使用批量翻译
@Dict(dicCode = "dept_id", dicText = "dept_name", dictTable = "sys_depart")
private String deptId;

// ❌ 避免：在循环中单独处理字典翻译
// 框架已自动优化为批量查询，无需手动处理
```

### 4. 字典数据维护

#### 4.1 字典数据添加模板

```sql
-- 生成字典ID
SET @dict_id = REPLACE(UUID(), '-', '');

-- 添加字典类型
INSERT INTO `sys_dict` (
    `id`, `dict_code`, `dict_name`, `description`, `del_flag`, 
    `create_by`, `create_time`, `update_by`, `update_time`
) VALUES (
    @dict_id, 'your_dict_code', '字典名称', '字典描述', '0',
    'admin', NOW(), 'admin', NOW()
);

-- 生成字典项ID
SET @item_id_1 = REPLACE(UUID(), '-', '');
SET @item_id_2 = REPLACE(UUID(), '-', '');

-- 添加字典项
INSERT INTO `sys_dict_item` (
    `id`, `dict_id`, `item_text`, `item_value`, `item_color`, 
    `description`, `sort_order`, `status`, `create_by`, 
    `create_time`, `update_by`, `update_time`
) VALUES (
    @item_id_1, @dict_id, '选项文本1', '选项值1', '#000000',
    '选项描述1', 1, 1, 'admin', NOW(), 'admin', NOW()
), (
    @item_id_2, @dict_id, '选项文本2', '选项值2', '#000000',
    '选项描述2', 2, 1, 'admin', NOW(), 'admin', NOW()
);
```

#### 4.2 字典维护注意事项

- **dict_code必须全局唯一**
- **item_value建议使用数字或简单字符串**
- **sort_order控制显示顺序，数字越小越靠前**
- **status控制启用状态：1=启用，0=禁用**
- **删除字典项时建议使用软删除**

## 常见问题与解决方案

### 1. 字典翻译不生效

**问题现象：**
添加了`@Dict`注解但返回数据中没有`_dictText`字段。

**可能原因及解决方案：**

#### 1.1 字典数据不存在
```sql
-- 检查字典是否存在
SELECT * FROM sys_dict WHERE dict_code = 'your_dict_code';

-- 检查字典项是否存在且启用
SELECT * FROM sys_dict_item WHERE dict_id = 'your_dict_id' AND status = 1;
```

#### 1.2 注解参数错误
```java
// ❌ 错误：表字典参数不完整
@Dict(dicCode = "username", dictTable = "sys_user")  // 缺少 dicText

// ✅ 正确：表字典参数完整
@Dict(dicCode = "username", dicText = "realname", dictTable = "sys_user")
```

#### 1.3 字段值为空
```java
// 字典翻译会跳过空值字段
if (oConvertUtils.isEmpty(value)) {
    continue;
}
```

### 2. 性能问题

**问题现象：**
接口响应缓慢，特别是数据量大的列表接口。

**解决方案：**

#### 2.1 启用Redis缓存
```properties
# application.yml
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
```

#### 2.2 优化字典数据
```sql
-- 为字典表添加索引
CREATE INDEX idx_dict_code ON sys_dict(dict_code);
CREATE INDEX idx_dict_item_value ON sys_dict_item(item_value);
CREATE INDEX idx_dict_item_status ON sys_dict_item(status);
```

### 3. 缓存更新问题

**问题现象：**
修改字典数据后，接口返回的还是旧数据。

**解决方案：**

#### 3.1 手动清除缓存
```java
// 清除普通字典缓存
redisTemplate.delete("sys:cache:dict::" + dictCode + ":*");

// 清除表字典缓存
redisTemplate.delete("sys:cache:dictTable::SimpleKey [" + table + "," + text + "," + code + ",*]");
```

#### 3.2 重启应用
```bash
# 简单粗暴的方式：重启应用
systemctl restart your-application
```

### 4. 多值翻译问题

**问题现象：**
逗号分隔的多个值只翻译了第一个。

**解决方案：**

#### 4.1 检查数据格式
```java
// ✅ 正确：使用英文逗号分隔
private String roleIds = "1,2,3";

// ❌ 错误：使用中文逗号或其他分隔符
private String roleIds = "1，2，3";  // 中文逗号
private String roleIds = "1;2;3";   // 分号分隔
```

#### 4.2 检查字典数据完整性
```sql
-- 确保所有值都有对应的字典项
SELECT item_value FROM sys_dict_item 
WHERE dict_id = (SELECT id FROM sys_dict WHERE dict_code = 'your_dict_code')
AND item_value IN ('1', '2', '3');
```

## 扩展功能

### 1. 自定义字典翻译

如果需要自定义字典翻译逻辑，可以实现`CommonAPI`接口：

```java
@Service
public class CustomDictService implements CommonAPI {
    
    @Override
    public String translateDict(String code, String key) {
        // 自定义翻译逻辑
        return customTranslateLogic(code, key);
    }
    
    @Override
    public String translateDictFromTable(String table, String text, String code, String key) {
        // 自定义表字典翻译逻辑
        return customTableTranslateLogic(table, text, code, key);
    }
}
```

### 2. 禁用字典翻译

如果某个接口不需要字典翻译，可以在Controller方法上添加注解：

```java
@RestController
public class UserController {
    
    /**
     * 该方法不会进行字典翻译
     */
    @GetMapping("/list")
    @AutoDict(false)  // 禁用字典翻译
    public Result<List<User>> getUserList() {
        // 业务逻辑
    }
}
```

## 总结

字典注解是Jeecg-boot框架的核心功能之一，正确使用可以大大简化前端开发工作，提升用户体验。在使用过程中需要注意：

1. **合理选择翻译模式**：普通字典用于固定枚举值，表字典用于关联数据
2. **注意性能优化**：启用Redis缓存，合理设计字典数据结构
3. **规范命名约定**：使用统一的字典编码命名规范
4. **及时维护数据**：保持字典数据的准确性和完整性

通过遵循本规范，可以充分发挥字典注解的优势，构建高效、易维护的应用系统。 
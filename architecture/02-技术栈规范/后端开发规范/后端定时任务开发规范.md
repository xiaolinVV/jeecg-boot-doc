# 定时任务开发规范文档

## 概述

本文档基于 jeecg-boot 项目中的 Quartz 框架定时任务开发模式，制定了详细的开发规范。项目采用 Quartz 框架进行任务调度，支持通过后台管理系统进行在线配置和管理。

**核心原则：简单优先，按需复杂化**

## 快速开始：简单定时任务实现（推荐用于大多数场景）

### 适用场景
- 数据清理任务（如删除过期记录）
- 状态更新任务（如更新超时订单状态）
- 简单的数据同步和处理
- 执行时间预期小于5分钟的任务
- 数据量小于1000条的处理

### 简单实现模板

```java
package org.jeecg.modules.[业务模块].job;

import lombok.extern.slf4j.Slf4j;
import org.quartz.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * [业务功能描述]定时任务
 * [详细描述任务的作用和执行逻辑]
 *
 * @author [开发者姓名]
 * @date [创建日期]
 * @version 1.0
 */
@DisallowConcurrentExecution
@Slf4j
@Component
public class [业务模块][具体功能]Job implements Job {

    @Autowired
    private [相关Service] [serviceName];

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        long startTime = System.currentTimeMillis();
        String jobName = this.getClass().getSimpleName();

        log.info("开始执行定时任务：{}", jobName);

        try {
            // 执行具体业务逻辑
            processBusinessLogic();

            // 记录执行结果
            long duration = System.currentTimeMillis() - startTime;
            log.info("定时任务执行完成：{}，耗时：{}ms", jobName, duration);

        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("定时任务执行失败：{}，耗时：{}ms", jobName, duration, e);
            throw new JobExecutionException(e);
        }
    }

    /**
     * 执行具体业务逻辑
     */
    private void processBusinessLogic() {
        // 示例：查询需要处理的数据
        List<DataEntity> records = serviceName.queryRecordsToProcess();

        if (records.isEmpty()) {
            log.info("没有需要处理的数据");
            return;
        }

        // 示例：批量处理数据
        boolean result = serviceName.processRecords(records);

        log.info("处理完成，影响{}条记录，结果：{}", records.size(), result ? "成功" : "失败");
    }
}
```

### 实际案例：余额充值日志清理任务

```java
@DisallowConcurrentExecution
@Slf4j
@Component
public class PayBalanceLogCleanupJob implements Job {

    @Autowired
    private IPayBalanceLogService payBalanceLogService;

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        long startTime = System.currentTimeMillis();
        String jobName = this.getClass().getSimpleName();

        log.info("开始执行定时任务：{}", jobName);

        try {
            // 计算3小时前的时间点
            Date timeoutPoint = new Date(System.currentTimeMillis() - 3 * 60 * 60 * 1000L);

            // 查询超时记录
            LambdaQueryWrapper<PayBalanceLog> queryWrapper = new LambdaQueryWrapper<>();
            queryWrapper.lt(PayBalanceLog::getCreateTime, timeoutPoint)
                    .eq(PayBalanceLog::getPayStatus, "0")      // 未支付
                    .eq(PayBalanceLog::getBackStatus, "0")     // 未回调
                    .eq(PayBalanceLog::getDelFlag, "0")        // 未删除
                    .last("LIMIT 500");

            List<PayBalanceLog> recordsToDelete = payBalanceLogService.list(queryWrapper);

            if (recordsToDelete.isEmpty()) {
                log.info("没有待清理的超时记录");
                return;
            }

            // 删除记录
            List<String> idsToDelete = recordsToDelete.stream()
                    .map(PayBalanceLog::getId)
                    .toList();

            boolean result = payBalanceLogService.removeByIds(idsToDelete);

            // 记录执行结果
            long duration = System.currentTimeMillis() - startTime;
            log.info("定时任务执行完成：{}，删除{}条记录，结果：{}，耗时：{}ms",
                    jobName, recordsToDelete.size(), result ? "成功" : "失败", duration);

        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("定时任务执行失败：{}，耗时：{}ms", jobName, duration, e);
            throw new JobExecutionException(e);
        }
    }
}
```

### 何时使用简单实现

✅ **推荐使用简单实现的场景：**
- 数据量小于1000条
- 执行时间预期小于5分钟
- 逻辑简单的CRUD操作
- 定期清理、状态更新等常规任务
- 不需要复杂的错误恢复机制

❌ **不适合简单实现的场景：**
- 数据量大于10000条
- 执行时间可能超过30分钟
- 需要复杂的分批处理和进度监控
- 大数据量的ETL处理任务

## 1. 技术架构

### 1.1 核心组件

- **Quartz Scheduler**: 任务调度核心引擎
- **QuartzJobController**: 定时任务管理接口
- **QuartzJobService**: 定时任务业务逻辑
- **Job接口**: 具体任务执行逻辑

### 1.2 数据库支持

```sql
-- 定时任务配置表
sys_quartz_job
├── id                  -- 任务ID
├── job_class_name      -- 任务类名（完整包路径）
├── cron_expression     -- Cron表达式
├── parameter          -- 任务参数
├── description        -- 任务描述
├── status             -- 任务状态（0:正常, -1:停止）
└── ...                -- 其他通用字段
```

## 2. 命名规范

### 2.1 类命名规范

```java
// 格式：业务模块 + 具体功能 + Job
// 示例：
MemberStoreSubsidyStatusJob     // 会员店铺补助金状态更新任务
StoreLevelAssessmentJob         // 店铺等级评定任务
OrderTimeoutCancelJob           // 订单超时取消任务
```

### 2.2 包路径规范

```
src/main/java/org/jeecg/modules/
├── [业务模块]/
│   └── job/                    # 定时任务目录
│       ├── XxxJob.java         # 具体任务类
│       └── ...
```

**实际示例：**
```
org.jeecg.modules.member.job.MemberStoreSubsidyStatusJob
org.jeecg.modules.store.job.StoreLevelAssessmentJob
org.jeecg.modules.order.job.OrderTimeoutCancelJob
```

### 2.3 方法命名规范

- **execute()**: 必须实现的任务执行方法
- **processXxx()**: 处理具体业务逻辑的私有方法
- **validateXxx()**: 参数验证方法
- **cleanupXxx()**: 清理操作方法

## 3. 代码实现规范

### 3.1 简化基础模板（推荐）

**适用于大多数常规定时任务：**

```java
package org.jeecg.modules.[业务模块].job;

import lombok.extern.slf4j.Slf4j;
import org.quartz.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * [业务功能描述]定时任务
 *
 * @author [开发者姓名]
 * @date [创建日期]
 * @version 1.0
 */
@DisallowConcurrentExecution
@Slf4j
@Component
public class [业务模块][具体功能]Job implements Job {

    @Autowired
    private [相关Service] [serviceName];

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        long startTime = System.currentTimeMillis();
        String jobName = this.getClass().getSimpleName();

        log.info("开始执行定时任务：{}", jobName);

        try {
            // 执行具体业务逻辑
            processBusinessLogic();

            // 记录执行结果
            long duration = System.currentTimeMillis() - startTime;
            log.info("定时任务执行完成：{}，耗时：{}ms", jobName, duration);

        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("定时任务执行失败：{}，耗时：{}ms", jobName, duration, e);
            throw new JobExecutionException(e);
        }
    }

    /**
     * 执行具体业务逻辑
     */
    private void processBusinessLogic() {
        // 具体业务处理逻辑
        log.info("开始执行业务逻辑");

        // 示例代码
        // List<Entity> records = serviceName.queryRecords();
        // serviceName.processRecords(records);

        log.info("业务逻辑执行完成");
    }
}
```

    /**
     * 执行具体业务逻辑
     */
    private void processBusinessLogic() {
        // 具体业务处理逻辑
        log.info("开始执行业务逻辑");

        // 示例：批量处理逻辑
        int processedCount = 0;
        // 业务处理代码...

        log.info("业务逻辑执行完成，处理记录数：{}", processedCount);
    }
}
```

### 3.2 高级模板（复杂场景使用）

**仅在以下场景使用：**
- 需要参数化配置
- 需要状态持久化
- 复杂的分批处理逻辑

```java
package org.jeecg.modules.[业务模块].job;

import lombok.extern.slf4j.Slf4j;
import org.quartz.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * [业务功能描述]定时任务（高级版本）
 *
 * @author [开发者姓名]
 * @date [创建日期]
 * @version 1.0
 */
@PersistJobDataAfterExecution
@DisallowConcurrentExecution
@Slf4j
@Component
public class [业务模块][具体功能]Job implements Job {

    @Autowired
    private [相关Service] [serviceName];

    // 可配置参数（通过任务参数设置）
    private Integer batchSize = 100;

    public void setBatchSize(Integer batchSize) {
        this.batchSize = batchSize;
    }
    
    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        long startTime = System.currentTimeMillis();
        String jobName = this.getClass().getSimpleName();

        log.info("开始执行定时任务：{}", jobName);

        try {
            Date now = new Date();

            // 查询条件：店铺补助金(50) + 收入类型(0) + 可用状态(0) + 过期时间小于当前时间
            log.info("开始查询过期的店铺补助金记录");
            LambdaUpdateWrapper<MemberAccountCapital> updateWrapper = new LambdaUpdateWrapper<>();
            updateWrapper.eq(MemberAccountCapital::getPayType, "50")
                    .eq(MemberAccountCapital::getGoAndCome, "0")
                    .eq(MemberAccountCapital::getStoreSubsidyStatus, "0")
                    .lt(MemberAccountCapital::getExpireTime, now)
                    .eq(MemberAccountCapital::getDelFlag, "0");

            // 更新为已过期状态(1)
            updateWrapper.set(MemberAccountCapital::getStoreSubsidyStatus, "1");

            // 执行更新
            log.info("开始更新过期补助金状态");
            boolean result = memberAccountCapitalService.update(updateWrapper);

            // 查询已过期的补助金数量用于统计
            long expiredCount = memberAccountCapitalService.count(
                new LambdaQueryWrapper<MemberAccountCapital>()
                    .eq(MemberAccountCapital::getPayType, "50")
                    .eq(MemberAccountCapital::getGoAndCome, "0")
                    .eq(MemberAccountCapital::getStoreSubsidyStatus, "1")
                    .lt(MemberAccountCapital::getExpireTime, now)
                    .eq(MemberAccountCapital::getDelFlag, "0")
            );

            // 记录执行结果
            long duration = System.currentTimeMillis() - startTime;
            log.info("定时任务执行完成：{}，更新结果：{}，已过期补助金数量：{}，耗时：{}ms",
                    jobName, result ? "成功" : "失败", expiredCount, duration);

        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("定时任务执行失败：{}，耗时：{}ms", jobName, duration, e);
            throw new JobExecutionException(e);
        }
    }
}
```

### 3.3 带参数的定时任务示例

```java
package org.jeecg.modules.order.job;

import lombok.extern.slf4j.Slf4j;
import org.quartz.Job;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.springframework.stereotype.Component;

/**
 * 带参数的定时任务示例
 * 
 * @author 开发者
 * @date 2024-01-01
 * @version 1.0
 */
@Slf4j
@Component
public class SampleParamJob implements Job {
    
    // 参数字段（需要提供setter方法）
    private String parameter;
    private Integer timeoutMinutes;
    
    public void setParameter(String parameter) {
        this.parameter = parameter;
    }
    
    public void setTimeoutMinutes(Integer timeoutMinutes) {
        this.timeoutMinutes = timeoutMinutes;
    }
    
    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        log.info("开始执行带参数的定时任务");
        
        try {
            // 从JobDataMap获取参数（如果需要）
            JobDataMap dataMap = jobExecutionContext.getJobDetail().getJobDataMap();
            String extraParam = dataMap.getString("extraParam");
            
            log.info("执行参数 - parameter: {}, timeoutMinutes: {}, extraParam: {}", 
                    parameter, timeoutMinutes, extraParam);
            
            // 执行具体业务逻辑
            processWithParams();
            
            log.info("带参数的定时任务执行完成");
            
        } catch (Exception e) {
            log.error("带参数的定时任务执行失败", e);
            throw new JobExecutionException(e);
        }
    }
    
    private void processWithParams() {
        // 使用参数执行具体业务逻辑
        log.info("处理业务逻辑，超时时间：{}分钟", timeoutMinutes);
    }
}
```

## 4. 必须实现的接口和注解

### 4.1 必须实现的接口

```java
import org.quartz.Job;

public class YourJob implements Job {
    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        // 必须实现此方法
    }
}
```

### 4.2 必须使用的注解

```java
@Slf4j                      // 日志注解（推荐）
@Component                  // Spring组件注解（必须）
public class YourJob implements Job {
    // 类实现
}
```

### 4.3 依赖注入注解

```java
@Autowired                  // 服务依赖注入
private YourService yourService;

@Autowired                  // 可选：系统API注入
private ISysBaseAPI sysBaseAPI;
```

## 5. 异常处理和日志记录规范

### 5.1 日志记录标准

```java
@Override
public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
    long startTime = System.currentTimeMillis();
    String jobName = this.getClass().getSimpleName();

    // 1. 任务开始日志（INFO级别）- 必须记录
    log.info("开始执行定时任务：{}", jobName);

    try {
        // 2. 关键业务步骤日志（INFO级别）
        log.info("开始查询待处理数据");
        List<DataEntity> dataList = queryPendingData();
        log.info("查询到待处理数据{}条", dataList.size());

        // 3. 批量处理进度日志（INFO级别）
        int processedCount = 0;
        for (DataEntity data : dataList) {
            processData(data);
            processedCount++;

            // 每处理100条记录一次进度日志
            if (processedCount % 100 == 0) {
                log.info("已处理{}条记录", processedCount);
            }
        }

        // 4. 任务完成日志（INFO级别）- 必须记录
        long duration = System.currentTimeMillis() - startTime;
        log.info("定时任务执行完成：{}，处理{}条记录，耗时：{}ms", jobName, processedCount, duration);

    } catch (Exception e) {
        // 5. 异常日志（ERROR级别）- 必须记录
        long duration = System.currentTimeMillis() - startTime;
        log.error("定时任务执行失败：{}，耗时：{}ms", jobName, duration, e);
        throw new JobExecutionException(e);
    }
}
```

### 5.2 异常处理策略

```java
@Override
public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
    try {
        // 业务逻辑
        
    } catch (BusinessException e) {
        // 业务异常：记录日志但不抛出JobExecutionException
        log.error("业务处理异常：{}", e.getMessage());
        
    } catch (DataAccessException e) {
        // 数据访问异常：记录日志并抛出JobExecutionException
        log.error("数据访问异常", e);
        throw new JobExecutionException(e);
        
    } catch (Exception e) {
        // 其他未知异常：记录详细日志并抛出JobExecutionException
        log.error("任务执行发生未知异常", e);
        throw new JobExecutionException(e);
    }
}
```

### 5.3 异常通知机制

```java
/**
 * 发送异常告警
 */
private void sendErrorAlert(Exception e) {
    try {
        // 发送邮件、短信或系统消息
        MessageDTO messageDTO = new MessageDTO();
        messageDTO.setTitle("定时任务执行异常");
        messageDTO.setContent("任务名称：" + this.getClass().getSimpleName() + 
                             "\n异常信息：" + e.getMessage());
        // sysBaseAPI.sendMessage(messageDTO);
        
    } catch (Exception ex) {
        log.error("发送异常告警失败", ex);
    }
}
```

## 6. 参数传递和配置方式

### 6.1 简单参数传递

**定时任务类：**
```java
public class ParameterJob implements Job {
    private String parameter;      // 文本参数
    private Integer batchSize;     // 数字参数
    private Boolean enableFlag;    // 布尔参数
    
    // 必须提供setter方法
    public void setParameter(String parameter) {
        this.parameter = parameter;
    }
    
    public void setBatchSize(Integer batchSize) {
        this.batchSize = batchSize;
    }
    
    public void setEnableFlag(Boolean enableFlag) {
        this.enableFlag = enableFlag;
    }
}
```

**后台配置：**
```json
{
    "parameter": "测试参数",
    "batchSize": 100,
    "enableFlag": true
}
```

### 6.2 复杂参数传递

**使用JobDataMap：**
```java
@Override
public void execute(JobExecutionContext context) throws JobExecutionException {
    JobDataMap dataMap = context.getJobDetail().getJobDataMap();
    
    String configJson = dataMap.getString("config");
    Map<String, Object> config = JSON.parseObject(configJson, Map.class);
    
    // 使用配置参数
    String businessType = (String) config.get("businessType");
    Integer timeoutMinutes = (Integer) config.get("timeoutMinutes");
}
```

### 6.3 配置参数验证

```java
private void validateParameters() throws JobExecutionException {
    if (StringUtils.isBlank(parameter)) {
        throw new JobExecutionException("参数parameter不能为空");
    }
    
    if (batchSize == null || batchSize <= 0) {
        throw new JobExecutionException("batchSize必须大于0");
    }
    
    if (timeoutMinutes != null && timeoutMinutes < 1) {
        throw new JobExecutionException("timeoutMinutes必须大于等于1");
    }
}
```

## 7. 最佳实践和性能优化

### 7.1 核心原则

1. **简单优先** - 优先使用最简单的实现方式
2. **按需复杂化** - 只有在确实需要时才增加复杂度
3. **场景驱动** - 根据具体业务场景选择合适的实现方式
4. **可读性第一** - 代码的可读性和可维护性比功能完备性更重要

### 7.2 实现方式选择指导

#### 7.2.1 简单实现 vs 复杂实现

| 场景特征 | 简单实现 | 复杂实现 |
|----------|----------|----------|
| 数据量 | < 1000条 | > 10000条 |
| 执行时间 | < 5分钟 | > 30分钟 |
| 业务逻辑 | 简单CRUD | 复杂ETL处理 |
| 错误恢复 | 基础异常处理 | 复杂恢复机制 |
| 监控需求 | 基础日志 | 详细进度监控 |

#### 7.2.2 常见任务类型推荐

**数据清理任务** → 简单实现
```java
// 推荐：直接查询和删除
List<Entity> expiredRecords = service.queryExpiredRecords();
service.deleteRecords(expiredRecords);
```

**状态更新任务** → 简单实现
```java
// 推荐：批量更新
service.updateExpiredStatus();
```

**大数据量处理** → 复杂实现
```java
// 需要分批处理、进度监控等复杂机制
```

### 7.3 防重复执行机制

**推荐使用@DisallowConcurrentExecution注解**：

```java
@DisallowConcurrentExecution  // 防止同一任务并发执行
@Slf4j
@Component
public class YourJob implements Job {
    // 任务实现
}
```

**注解说明**：
- **@DisallowConcurrentExecution**：禁止同一个Job的多个实例并发执行
- **@PersistJobDataAfterExecution**：仅在需要状态持久化时使用

---

## 8. 高级用法：复杂批量处理（特殊场景）

**⚠️ 仅在以下场景使用：**
- 数据量超过10000条
- 执行时间可能超过30分钟
- 需要复杂的进度监控和错误恢复

### 8.1 避免的问题

**❌ 不推荐使用无限循环：**

```java
// 问题：执行时间不可控
while (true) {
    List<DataEntity> dataList = dataService.queryPendingData(batchSize);
    if (dataList.isEmpty()) break;
    // 处理逻辑...
}
```

### 8.2 复杂批量处理实现

**使用双重限制机制（时间+记录数）：**

```java
@DisallowConcurrentExecution
@Slf4j
@Component
public class ComplexBatchJob implements Job {

    @Autowired
    private DataService dataService;

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        long startTime = System.currentTimeMillis();
        long maxExecutionTime = 30 * 60 * 1000; // 30分钟最大执行时间
        int maxRecords = 10000; // 单次最大处理记录数
        int batchSize = 100;    // 批次大小
        String jobName = this.getClass().getSimpleName();

        log.info("开始执行复杂批量处理任务：{}，最大执行时间：{}分钟，最大记录数：{}",
                jobName, maxExecutionTime / 60000, maxRecords);

        try {
            int totalProcessed = 0;
            int successCount = 0;
            int errorCount = 0;

            while (totalProcessed < maxRecords) {
                // 检查执行时间
                if (System.currentTimeMillis() - startTime > maxExecutionTime) {
                    log.warn("任务执行时间超过限制，优雅退出，已处理{}条记录", totalProcessed);
                    break;
                }

                // 查询待处理数据
                int currentBatchSize = Math.min(batchSize, maxRecords - totalProcessed);
                List<DataEntity> dataList = dataService.queryPendingData(currentBatchSize);

                if (dataList.isEmpty()) {
                    log.info("没有待处理数据，任务完成");
                    break;
                }

                // 批量处理
                for (DataEntity data : dataList) {
                    try {
                        dataService.processData(data);
                        successCount++;
                    } catch (Exception e) {
                        log.warn("处理数据失败，ID：{}，错误：{}", data.getId(), e.getMessage());
                        errorCount++;
                    }
                }

                totalProcessed += dataList.size();

                // 进度日志
                if (totalProcessed % 1000 == 0) {
                    long duration = System.currentTimeMillis() - startTime;
                    log.info("处理进度：{}条，成功：{}，失败：{}，耗时：{}ms",
                            totalProcessed, successCount, errorCount, duration);
                }
            }

            // 记录执行结果
            long duration = System.currentTimeMillis() - startTime;
            log.info("复杂批量处理任务执行完成：{}，总处理：{}条，成功：{}，失败：{}，耗时：{}ms",
                    jobName, totalProcessed, successCount, errorCount, duration);

            log.error("复杂批量处理任务执行失败：{}，耗时：{}ms", jobName, duration, e);
            throw new JobExecutionException(e);
        }
    }
}
```

**关键特性**：
- 双重限制机制：时间限制 + 记录数限制
- 进度监控：每1000条记录输出进度日志
- 异常处理：单条记录失败不影响整体执行
- 优雅退出：超时时安全停止任务

### 8.3 参数化配置（高级特性）

**⚠️ 仅在需要灵活配置时使用：**

```java
@PersistJobDataAfterExecution
@DisallowConcurrentExecution
@Slf4j
@Component
public class ConfigurableBatchJob implements Job {

    // 可通过任务参数配置
    private Integer maxExecutionMinutes = 30;    // 最大执行时间（分钟）
    private Integer maxRecords = 10000;          // 最大处理记录数
    private Integer batchSize = 100;             // 批次大小
    private Integer progressLogInterval = 1000;   // 进度日志间隔

    // setter方法用于参数注入
    public void setMaxExecutionMinutes(Integer maxExecutionMinutes) {
        this.maxExecutionMinutes = maxExecutionMinutes;
    }

    public void setMaxRecords(Integer maxRecords) {
        this.maxRecords = maxRecords;
    }

    public void setBatchSize(Integer batchSize) {
        this.batchSize = batchSize;
    }

    public void setProgressLogInterval(Integer progressLogInterval) {
        this.progressLogInterval = progressLogInterval;
    }

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        long startTime = System.currentTimeMillis();
        long maxExecutionTime = maxExecutionMinutes * 60 * 1000L;
        String jobName = this.getClass().getSimpleName();

        log.info("开始执行参数化批量任务：{}，配置参数 - 最大执行时间：{}分钟，最大记录数：{}，批次大小：{}",
                jobName, maxExecutionMinutes, maxRecords, batchSize);

        // 使用7.1.2的优化逻辑，但参数可配置
        // ... 具体实现参考上面的混合限制机制
    }
}
```

**后台任务参数配置示例：**
```json
{
    "maxExecutionMinutes": 30,
    "maxRecords": 10000,
    "batchSize": 100,
    "progressLogInterval": 1000
}
```

#### 7.1.4 不同业务场景的推荐配置

| 业务场景 | 最大执行时间 | 最大记录数 | 批次大小 | 调度频率 |
|----------|--------------|------------|----------|----------|
| 数据清理任务 | 30分钟 | 10000条 | 100条 | 每小时 |
| 奖励分配任务 | 15分钟 | 5000条 | 50条 | 每30分钟 |
| 状态更新任务 | 10分钟 | 2000条 | 200条 | 每15分钟 |
| 大数据处理 | 60分钟 | 50000条 | 500条 | 每天 |

### 7.2 大数据量处理

**应用同样的限制机制避免长时间运行：**

```java
@Override
public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
    long startTime = System.currentTimeMillis();
    long maxExecutionTime = 60 * 60 * 1000; // 大数据量任务允许60分钟
    int maxRecords = 50000; // 最大处理50000条记录
    String jobName = this.getClass().getSimpleName();

    log.info("开始执行大数据量处理任务：{}，最大执行时间：{}分钟，最大处理记录数：{}",
            jobName, maxExecutionTime / 60000, maxRecords);

    try {
        int pageSize = 500;
        int pageNum = 1;
        AtomicInteger processedCount = new AtomicInteger(0);
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger errorCount = new AtomicInteger(0);

        while (processedCount.get() < maxRecords) {
            // 检查执行时间
            long currentTime = System.currentTimeMillis();
            if (currentTime - startTime > maxExecutionTime) {
                log.warn("大数据量任务执行时间超过限制，优雅退出：{}，已处理{}条记录",
                        jobName, processedCount.get());
                break;
            }

            Page<DataEntity> page = new Page<>(pageNum, pageSize);
            IPage<DataEntity> dataPage = dataService.queryByPage(page);

            if (dataPage.getRecords().isEmpty()) {
                log.info("没有更多数据，大数据量任务完成：{}", jobName);
                break;
            }

            // 检查是否会超过最大记录数限制
            List<DataEntity> recordsToProcess = dataPage.getRecords();
            if (processedCount.get() + recordsToProcess.size() > maxRecords) {
                recordsToProcess = recordsToProcess.subList(0, maxRecords - processedCount.get());
            }

            // 使用线程池并行处理（如果任务允许）
            List<CompletableFuture<Void>> futures = recordsToProcess.stream()
                .map(data -> CompletableFuture.runAsync(() -> {
                    try {
                        processData(data);
                        successCount.incrementAndGet();
                    } catch (Exception e) {
                        log.warn("处理数据异常，ID：{}，错误：{}", data.getId(), e.getMessage());
                        errorCount.incrementAndGet();
                    }
                    processedCount.incrementAndGet();
                }))
                .collect(Collectors.toList());

            // 等待当前批次完成
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

            pageNum++;

            // 进度日志和健康检查
            if (processedCount.get() % 1000 == 0) {
                long duration = currentTime - startTime;
                log.info("大数据量处理进度：{}条，成功：{}，失败：{}，耗时：{}ms，剩余时间：{}ms",
                        processedCount.get(), successCount.get(), errorCount.get(),
                        duration, maxExecutionTime - duration);
            }
        }

        // 退出原因分析
        String exitReason = "正常完成";
        if (processedCount.get() >= maxRecords) {
            exitReason = "达到最大记录数限制";
        } else if (System.currentTimeMillis() - startTime > maxExecutionTime) {
            exitReason = "达到最大执行时间限制";
        }

        long duration = System.currentTimeMillis() - startTime;
        log.info("大数据量处理任务执行完成：{}，退出原因：{}，总处理：{}条，成功：{}，失败：{}，耗时：{}ms",
                jobName, exitReason, processedCount.get(), successCount.get(), errorCount.get(), duration);

    } catch (Exception e) {
        long duration = System.currentTimeMillis() - startTime;
        log.error("大数据量处理任务执行失败：{}，耗时：{}ms", jobName, duration, e);
        throw new JobExecutionException(e);
    }
}
```

### 7.3 批量处理最佳实践总结

#### 7.3.1 核心原则

1. **避免无限循环** - 永远不要使用没有限制的 `while (true)`
2. **设置双重限制** - 同时限制执行时间和处理记录数
3. **优雅退出机制** - 确保任务可以安全中断和恢复
4. **详细进度日志** - 便于监控和问题排查
5. **参数可配置** - 支持根据实际情况调整参数

#### 7.3.2 推荐的限制参数

```java
// 通用批量处理任务
private static final long DEFAULT_MAX_EXECUTION_TIME = 30 * 60 * 1000; // 30分钟
private static final int DEFAULT_MAX_RECORDS = 10000; // 10000条记录
private static final int DEFAULT_BATCH_SIZE = 100; // 100条批次

// 大数据量处理任务
private static final long LARGE_DATA_MAX_EXECUTION_TIME = 60 * 60 * 1000; // 60分钟
private static final int LARGE_DATA_MAX_RECORDS = 50000; // 50000条记录
private static final int LARGE_DATA_BATCH_SIZE = 500; // 500条批次
```

#### 7.3.3 调度频率建议

- **宁可频繁调度，不要长时间运行**
- 根据数据量和处理复杂度合理设置调度间隔
- 监控任务执行情况，及时调整参数

### 7.4 防重复执行机制

#### 7.3.1 Quartz同步执行（推荐）

**优先使用Quartz框架提供的同步执行功能**来防止任务重复执行，这是最简单、最可靠的方式：

```java
package org.jeecg.modules.member.job;

import lombok.extern.slf4j.Slf4j;
import org.quartz.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * 使用Quartz同步执行的定时任务示例
 *
 * @PersistJobDataAfterExecution: 任务执行后持久化JobDataMap数据
 * @DisallowConcurrentExecution: 禁止并发执行，确保同一时间只有一个实例运行
 */
@PersistJobDataAfterExecution
@DisallowConcurrentExecution
@Slf4j
@Component
public class SyncExecutionJob implements Job {

    @Autowired
    private YourService yourService;

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        log.info("开始执行同步定时任务：{}", this.getClass().getSimpleName());

        try {
            // 当任务执行时间大于调度间隔时，会等待当前任务完成后再执行下一次
            processBusinessLogic();

            log.info("同步定时任务执行完成：{}", this.getClass().getSimpleName());

        } catch (Exception e) {
            log.error("同步定时任务执行失败：{}", this.getClass().getSimpleName(), e);
            throw new JobExecutionException(e);
        }
    }

    private void processBusinessLogic() {
        // 具体业务逻辑
        log.info("执行业务逻辑...");
    }
}
```

**关键注解说明：**

- **@DisallowConcurrentExecution**：
  - 禁止同一个Job的多个实例并发执行
  - 当任务执行时间超过调度间隔时，会等待当前任务完成
  - 适用于大部分业务场景，特别是数据处理类任务

- **@PersistJobDataAfterExecution**：
  - 任务执行后持久化JobDataMap中的数据变更
  - 通常与@DisallowConcurrentExecution一起使用
  - 适用于需要在任务间传递状态的场景

#### 7.3.2 自定义分布式锁（特殊场景）

**仅在以下特殊场景下考虑使用自定义分布式锁：**
- 需要跨不同Job类型的互斥执行
- 需要更细粒度的锁控制
- 需要自定义锁超时和重试逻辑

```java
@Override
public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
    // 使用项目中的TaskConcurrencyService
    String lockKey = "custom_job_lock:" + this.getClass().getSimpleName();

    try {
        // 尝试获取分布式锁，超时时间30分钟
        boolean lockAcquired = taskConcurrencyService.acquireTaskLock(lockKey, 1800);

        if (!lockAcquired) {
            log.warn("任务正在其他节点执行中，跳过本次执行：{}", this.getClass().getSimpleName());
            return;
        }

        try {
            // 执行任务逻辑
            processBusinessLogic();

        } finally {
            // 释放锁
            taskConcurrencyService.releaseTaskLock(lockKey);
        }

    } catch (Exception e) {
        log.error("任务执行失败：{}", this.getClass().getSimpleName(), e);
        throw new JobExecutionException(e);
    }
}
```

#### 7.4.3 选择建议

| 场景 | 推荐方案 | 理由 |
|------|----------|------|
| 普通定时任务 | @DisallowConcurrentExecution | 简单可靠，Quartz原生支持 |
| 数据处理任务 | @DisallowConcurrentExecution | 避免数据重复处理 |
| 长时间运行任务 | @DisallowConcurrentExecution | 自动等待上次执行完成 |
| 跨任务互斥 | 自定义分布式锁 | 需要更复杂的锁控制 |
| 集群环境 | @DisallowConcurrentExecution | Quartz集群原生支持 |

## 8. 测试和调试指南

### 8.1 单元测试

```java
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class MemberStoreSubsidyStatusJobTest {
    
    @Autowired
    private MemberStoreSubsidyStatusJob job;
    
    @MockBean
    private IMemberAccountCapitalService memberAccountCapitalService;
    
    @Test
    @Order(1)
    void testExecuteSuccess() throws JobExecutionException {
        // 模拟成功执行
        when(memberAccountCapitalService.update(any())).thenReturn(true);
        when(memberAccountCapitalService.count(any())).thenReturn(10L);
        
        JobExecutionContext context = mock(JobExecutionContext.class);
        
        // 执行测试
        assertDoesNotThrow(() -> job.execute(context));
        
        // 验证调用
        verify(memberAccountCapitalService, times(1)).update(any());
        verify(memberAccountCapitalService, times(1)).count(any());
    }
    
    @Test
    @Order(2)
    void testExecuteWithException() {
        // 模拟异常
        when(memberAccountCapitalService.update(any())).thenThrow(new RuntimeException("数据库异常"));
        
        JobExecutionContext context = mock(JobExecutionContext.class);
        
        // 验证异常抛出
        assertThrows(JobExecutionException.class, () -> job.execute(context));
    }
}
```

### 8.2 集成测试

```java
@SpringBootTest
@Transactional
@Rollback
class JobIntegrationTest {
    
    @Autowired
    private MemberStoreSubsidyStatusJob job;
    
    @Autowired
    private IMemberAccountCapitalService memberAccountCapitalService;
    
    @Test
    void testJobExecutionIntegration() throws JobExecutionException {
        // 准备测试数据
        MemberAccountCapital testData = new MemberAccountCapital();
        testData.setPayType("50");
        testData.setGoAndCome("0");
        testData.setStoreSubsidyStatus("0");
        testData.setExpireTime(new Date(System.currentTimeMillis() - 1000)); // 已过期
        testData.setDelFlag("0");
        memberAccountCapitalService.save(testData);
        
        // 执行任务
        JobExecutionContext context = mock(JobExecutionContext.class);
        job.execute(context);
        
        // 验证结果
        MemberAccountCapital updatedData = memberAccountCapitalService.getById(testData.getId());
        assertEquals("1", updatedData.getStoreSubsidyStatus());
    }
}
```

### 8.3 调试技巧

**1. 本地调试：**
```java
public static void main(String[] args) {
    // 创建Spring应用上下文
    ApplicationContext context = SpringApplication.run(Application.class, args);
    
    // 获取任务实例
    MemberStoreSubsidyStatusJob job = context.getBean(MemberStoreSubsidyStatusJob.class);
    
    // 手动执行任务
    try {
        job.execute(null);
    } catch (JobExecutionException e) {
        e.printStackTrace();
    }
}
```

**2. 日志配置：**
```yaml
logging:
  level:
    org.jeecg.modules.*.job: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%logger{50}] - %msg%n"
```

**3. 性能监控：**
```java
@Override
public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
    long startTime = System.currentTimeMillis();
    
    try {
        // 任务逻辑
        processBusinessLogic();
        
    } finally {
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;
        log.info("任务执行耗时：{}ms", duration);
        
        // 记录性能指标
        if (duration > 60000) { // 超过1分钟
            log.warn("任务执行时间过长：{}ms", duration);
        }
    }
}
```

## 9. 部署和运维注意事项

### 9.1 部署检查清单

**代码检查：**
- [ ] 任务类实现了`org.quartz.Job`接口
- [ ] 使用了`@Component`注解
- [ ] 包路径符合规范
- [ ] 异常处理完整
- [ ] 日志记录规范

**配置检查：**
- [ ] Cron表达式正确
- [ ] 参数格式正确
- [ ] 任务描述清晰
- [ ] 初始状态设置正确

**测试检查：**
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 性能测试满足要求
- [ ] 异常场景测试完成

### 9.2 日志记录和问题排查

#### 9.2.1 日志记录最佳实践

**定时任务只需要在关键业务逻辑部分添加详细的日志记录**，用于问题跟踪和排查：

```java
@Override
public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
    // 1. 任务开始日志（INFO级别）- 必须记录
    log.info("开始执行定时任务：{}", this.getClass().getSimpleName());

    try {
        // 2. 关键业务步骤日志（INFO级别）
        log.info("开始查询待处理数据");
        List<DataEntity> dataList = queryPendingData();
        log.info("查询到待处理数据{}条", dataList.size());

        // 3. 批量处理进度日志（INFO级别）
        int processedCount = 0;
        for (DataEntity data : dataList) {
            try {
                processData(data);
                processedCount++;

                // 每处理100条记录一次进度日志
                if (processedCount % 100 == 0) {
                    log.info("已处理{}条记录", processedCount);
                }

            } catch (Exception e) {
                // 4. 单条记录处理异常（WARN级别）
                log.warn("处理数据失败，ID：{}，错误：{}", data.getId(), e.getMessage());
            }
        }

        // 5. 任务完成日志（INFO级别）- 必须记录
        log.info("定时任务执行完成：{}，总处理{}条，成功{}条",
                this.getClass().getSimpleName(), dataList.size(), processedCount);

    } catch (Exception e) {
        // 6. 任务级别异常（ERROR级别）- 必须记录
        log.error("定时任务执行失败：{}", this.getClass().getSimpleName(), e);
        throw new JobExecutionException(e);
    }
}
```

#### 9.2.2 日志级别使用规范

| 日志级别 | 使用场景 | 示例 |
|----------|----------|------|
| **ERROR** | 任务执行失败、系统异常 | `log.error("任务执行失败", e)` |
| **WARN** | 业务异常、数据问题 | `log.warn("数据格式错误，跳过处理")` |
| **INFO** | 任务开始/结束、关键步骤、处理结果 | `log.info("处理完成，影响{}条记录", count)` |
| **DEBUG** | 详细的调试信息、参数值 | `log.debug("查询条件：{}", condition)` |

#### 9.2.3 关键信息记录要求

**必须记录的信息：**
```java
// 任务标识信息
log.info("任务名称：{}，执行时间：{}", this.getClass().getSimpleName(), new Date());

// 处理数据量统计
log.info("本次处理：查询{}条，成功{}条，失败{}条", totalCount, successCount, errorCount);

// 执行耗时统计
long startTime = System.currentTimeMillis();
// ... 业务逻辑
long duration = System.currentTimeMillis() - startTime;
log.info("任务执行耗时：{}ms", duration);

// 异常详细信息
catch (Exception e) {
    log.error("任务执行异常，错误类型：{}，错误信息：{}",
             e.getClass().getSimpleName(), e.getMessage(), e);
}
```

#### 9.2.4 性能监控日志

**简单的性能监控通过日志实现：**
```java
@Override
public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
    long startTime = System.currentTimeMillis();
    String jobName = this.getClass().getSimpleName();

    try {
        log.info("开始执行任务：{}", jobName);

        // 业务逻辑
        processBusinessLogic();

        // 成功完成
        long duration = System.currentTimeMillis() - startTime;
        log.info("任务执行成功：{}，耗时：{}ms", jobName, duration);

        // 性能预警
        if (duration > 300000) { // 超过5分钟
            log.warn("任务执行时间较长：{}，耗时：{}ms，建议优化", jobName, duration);
        }

    } catch (Exception e) {
        long duration = System.currentTimeMillis() - startTime;
        log.error("任务执行失败：{}，耗时：{}ms", jobName, duration, e);
        throw new JobExecutionException(e);
    }
}
```

### 9.3 故障排查

**常见问题和解决方案：**

1. **任务不执行**
   - 检查任务状态是否为"正常"
   - 验证Cron表达式是否正确
   - 确认调度器是否启动

2. **任务执行失败**
   - 查看应用日志获取详细错误信息
   - 检查数据库连接状态
   - 验证依赖服务可用性

3. **任务执行时间过长**
   - 分析SQL执行计划
   - 检查是否有死锁
   - 考虑优化批处理大小

4. **内存泄漏**
   - 检查是否正确释放资源
   - 验证大对象是否及时清理
   - 监控JVM内存使用情况

## 10. 开发流程指南

### 10.1 完整开发流程

**步骤1：需求分析和设计**
```markdown
1. 明确任务目的和业务需求
2. 设计任务执行逻辑
3. 确定执行频率和时间
4. 识别依赖服务和资源
5. 评估性能和风险
```

**步骤2：编写任务类**
```java
// 1. 创建任务类文件
// 2. 实现Job接口
// 3. 添加必要注解
// 4. 注入依赖服务
// 5. 实现execute方法
// 6. 添加异常处理和日志
```

**步骤3：编写单元测试**
```java
// 1. 创建测试类
// 2. Mock依赖服务
// 3. 测试正常执行场景
// 4. 测试异常场景
// 5. 验证业务逻辑正确性
```

**步骤4：本地测试和调试**
```bash
# 1. 启动应用
mvn spring-boot:run

# 2. 手动执行任务测试
# 3. 检查日志输出
# 4. 验证业务结果
```

**步骤5：配置定时任务**

通过后台管理系统配置：

1. **登录管理后台**
   - 访问：`http://your-domain/admin`
   - 使用管理员账号登录

2. **进入定时任务管理**
   - 导航：`系统管理` -> `定时任务`

3. **新增定时任务**
   ```
   任务类名：org.jeecg.modules.member.job.MemberStoreSubsidyStatusJob
   Cron表达式：0 0/10 * * * ?
   参数：{"batchSize": 100}
   描述：店铺补助金状态更新定时任务，检查过期的店铺补助金并更新其状态，10分钟检查一次
   状态：正常
   ```

4. **保存并启动任务**
   - 点击"保存并启动任务"按钮
   - 系统会自动将任务加入调度

**步骤6：部署验证**
```bash
# 1. 部署到测试环境
# 2. 验证任务正常调度
# 3. 监控任务执行日志
# 4. 验证业务结果正确性
```

**步骤7：生产发布**
```bash
# 1. 部署到生产环境
# 2. 配置生产环境定时任务
# 3. 设置监控告警
# 4. 文档更新
```

### 10.2 后台管理系统配置指南

**定时任务配置界面字段说明：**

| 字段 | 必填 | 说明 | 示例 |
|------|------|------|------|
| 任务类名 | 是 | 完整的Java类名 | `org.jeecg.modules.member.job.MemberStoreSubsidyStatusJob` |
| Cron表达式 | 是 | 定时执行的时间表达式 | `0 0/10 * * * ?` (每10分钟执行一次) |
| 参数 | 否 | JSON格式的任务参数 | `{"batchSize": 100, "timeoutMinutes": 30}` |
| 描述 | 是 | 任务功能描述 | `店铺补助金状态更新定时任务` |
| 状态 | 是 | 任务运行状态 | 正常(0) / 停止(-1) |

**常用Cron表达式：**
```
每分钟执行：       0 * * * * ?
每5分钟执行：      0 0/5 * * * ?
每小时执行：       0 0 * * * ?
每天凌晨1点执行：   0 0 1 * * ?
每周一上午8点执行： 0 0 8 ? * MON
每月1号凌晨执行：   0 0 0 1 * ?
```

**任务管理操作：**
- **启动**：将停止状态的任务设为运行状态
- **暂停**：暂停正在运行的任务
- **删除**：删除任务配置和调度
- **立即执行**：手动触发任务执行一次
- **修改**：更新任务配置

### 10.3 代码提交和文档规范

**代码提交信息格式：**
```
feat(job): 新增店铺补助金状态更新定时任务

- 实现MemberStoreSubsidyStatusJob类
- 支持自动检查并更新过期补助金状态
- 添加完整的异常处理和日志记录
- 包含单元测试和集成测试

Tasks: #TASK-001
```

**必要文档更新：**
1. **API文档**：如果任务涉及新的API
2. **数据库文档**：如果涉及新的表结构
3. **部署文档**：更新部署检查清单
4. **运维手册**：添加新任务的监控配置

## 11. 附录

### 11.1 项目中的定时任务示例

| 任务类 | 功能描述 | 执行频率 | 位置 |
|--------|----------|----------|------|
| `MemberStoreSubsidyStatusJob` | 店铺补助金状态更新 | 每10分钟 | `org.jeecg.modules.member.job` |
| `StoreLevelAssessmentJob` | 店铺等级评定 | 每月1号 | `org.jeecg.modules.store.job` |
| `OrderTimeoutCancelJob` | 订单超时取消 | 每5分钟 | `org.jeecg.modules.order.job` |
| `MarketingCertificateGroupManageJob` | 拼好券超时过期处理 | 每5分钟 | `org.jeecg.modules.marketing.job` |

### 11.2 相关配置文件

**application.yml 配置：**
```yaml
# Quartz配置
spring:
  quartz:
    job-store-type: jdbc
    properties:
      org:
        quartz:
          scheduler:
            instanceName: QuartzScheduler
            instanceId: AUTO
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: QRTZ_
            isClustered: true
            clusterCheckinInterval: 10000
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            threadCount: 10
            threadPriority: 5
            threadsInheritContextClassLoaderOfInitializingThread: true
```

### 11.3 常见错误和解决方案

**错误1：ClassNotFoundException**
```
原因：任务类路径错误或类不存在
解决：检查包路径和类名是否正确
```

**错误2：JobExecutionException**
```
原因：任务执行过程中发生异常
解决：查看具体异常信息，修复业务逻辑问题
```

**错误3：任务重复执行**
```
原因：集群环境下任务并发执行
解决：优先使用@DisallowConcurrentExecution注解防止重复执行，特殊场景可考虑自定义分布式锁
```

**错误4：内存泄漏**
```
原因：大对象未及时释放或存在循环引用
解决：优化内存使用，及时清理资源
```

---

## 总结

**核心原则：简单优先，按需复杂化**

### 快速决策指南

1. **大多数场景（推荐）**：使用简单实现模板
   - 数据量 < 1000条
   - 执行时间 < 5分钟
   - 简单的CRUD操作

2. **特殊场景**：使用复杂实现
   - 数据量 > 10000条
   - 执行时间 > 30分钟
   - 需要复杂的分批处理和监控

### 关键要点

- **防重复执行**：优先使用`@DisallowConcurrentExecution`注解
- **日志记录**：开始、完成、异常三个关键日志点已足够
- **异常处理**：捕获异常并抛出`JobExecutionException`
- **避免过度设计**：不要为简单任务添加复杂的参数化配置

### 实际案例参考

参考本文档中的`PayBalanceLogCleanupJob`示例，这是一个典型的简单实现案例，适用于大多数数据清理和状态更新任务。

---

**文档版本：** 3.0
**最后更新：** 2025-01-08
**维护人员：** 技术团队
**更新内容：**
- 重大更新：确立"简单优先，按需复杂化"的核心原则
- 新增简单实现模板和实际案例
- 重新组织文档结构，简单实现优先
- 简化基础模板，移除不必要的复杂逻辑